import { useMtgaApi } from "./useMtgaApi"
import { listen } from "@tauri-apps/api/event"
import { isBundledRuntime, isTauriRuntime } from "./runtime"
import type {
  AppInfo,
  ConfigGroup,
  ConfigPayload,
  InvokeResult,
  LogEventPayload,
  LogPullResult,
  MainTabKey,
  ProxyStartStepEvent,
} from "./mtgaTypes"

type RuntimeOptions = {
  debugMode: boolean
  disableSslStrict: boolean
  forceStream: boolean
  streamMode: "true" | "false"
}

const DEFAULT_APP_INFO: AppInfo = {
  display_name: "MTGA",
  version: "v0.0.0",
  github_repo: "",
  ca_common_name: "MTGA_CA",
  api_key_visible_chars: 4,
  user_data_dir: "",
  default_user_data_dir: "",
}

const DEFAULT_RUNTIME_OPTIONS: RuntimeOptions = {
  debugMode: false,
  disableSslStrict: false,
  forceStream: false,
  streamMode: "true",
}

const FRONTEND_LOG_LIMIT = 2000

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === "object" && value !== null && !Array.isArray(value)

const isMainTabKey = (value: unknown): value is MainTabKey =>
  value === "cert" || value === "hosts" || value === "proxy"

const isProxyStepStatus = (
  value: unknown
): value is ProxyStartStepEvent["status"] =>
  value === "ok" || value === "skipped" || value === "failed"

const isProxyStartStepEvent = (
  value: unknown
): value is ProxyStartStepEvent => {
  if (!isRecord(value)) {
    return false
  }
  return isMainTabKey(value.step) && isProxyStepStatus(value.status)
}

const normalizeProxyStepPayload = (
  payload: unknown
): ProxyStartStepEvent | null => {
  if (isProxyStartStepEvent(payload)) {
    return payload
  }
  if (typeof payload === "string") {
    try {
      const parsed = JSON.parse(payload)
      if (isProxyStartStepEvent(parsed)) {
        return parsed
      }
    } catch {
      return null
    }
  }
  return null
}

const coerceText = (value: unknown) => {
  if (typeof value === "string") {
    return value
  }
  if (typeof value === "number") {
    return String(value)
  }
  if (isRecord(value)) {
    const candidates = [value["id"], value["value"], value["model_id"]]
    for (const candidate of candidates) {
      if (typeof candidate === "string") {
        return candidate
      }
    }
  }
  return ""
}

const clampIndex = (value: number, max: number) => {
  if (max <= 0) {
    return 0
  }
  return Math.min(Math.max(value, 0), max - 1)
}

export const useMtgaStore = () => {
  const api = useMtgaApi()

  const configGroups = useState<ConfigGroup[]>("mtga-config-groups", () => [])
  const currentConfigIndex = useState<number>("mtga-current-config-index", () => 0)
  const mappedModelId = useState<string>("mtga-mapped-model-id", () => "")
  const mtgaAuthKey = useState<string>("mtga-auth-key", () => "")
  const runtimeOptions = useState<RuntimeOptions>(
    "mtga-runtime-options",
    () => ({ ...DEFAULT_RUNTIME_OPTIONS })
  )
  const logs = useState<string[]>("mtga-logs", () => [])
  const logCursor = useState<number>("mtga-log-cursor", () => 0)
  const logStreamActive = useState<boolean>("mtga-log-stream-active", () => false)
  const appInfo = useState<AppInfo>("mtga-app-info", () => ({ ...DEFAULT_APP_INFO }))
  const initialized = useState<boolean>("mtga-initialized", () => false)
  const updateDialogOpen = useState<boolean>("mtga-update-dialog-open", () => false)
  const updateVersionLabel = useState<string>("mtga-update-version-label", () => "")
  const updateNotesHtml = useState<string>("mtga-update-notes-html", () => "")
  const updateReleaseUrl = useState<string>("mtga-update-release-url", () => "")
  const updateAutoChecked = useState<boolean>(
    "mtga-update-auto-checked",
    () => false
  )
  const panelNavTarget = useState<string | null>(
    "mtga-panel-nav-target",
    () => null
  )
  const panelNavSignal = useState<number>("mtga-panel-nav-signal", () => 0)
  const mainTabTarget = useState<MainTabKey | null>(
    "mtga-main-tab-target",
    () => null
  )
  const mainTabSignal = useState<number>("mtga-main-tab-signal", () => 0)
  const proxyStepListenerActive = useState<boolean>(
    "mtga-proxy-step-listener-active",
    () => false
  )
  const proxyStepQueue = useState<MainTabKey[]>(
    "mtga-proxy-step-queue",
    () => []
  )
  const proxyStepProcessing = useState<boolean>(
    "mtga-proxy-step-processing",
    () => false
  )

  let logPollTimer: ReturnType<typeof setTimeout> | null = null
  let logEventUnlisten: (() => void) | null = null
  let proxyStepUnlisten: (() => void) | null = null

  const drainProxyStepQueue = async () => {
    if (proxyStepProcessing.value) {
      return
    }
    proxyStepProcessing.value = true
    while (proxyStepQueue.value.length) {
      const step = proxyStepQueue.value.shift()
      if (!step) {
        continue
      }
      panelNavTarget.value = "main-tabs"
      panelNavSignal.value += 1
      mainTabTarget.value = step
      mainTabSignal.value += 1
      await nextTick()
      await new Promise((resolve) => setTimeout(resolve, 240))
    }
    proxyStepProcessing.value = false
  }

  const enqueueProxyStep = (step: MainTabKey) => {
    proxyStepQueue.value.push(step)
    void drainProxyStepQueue()
  }

  const appendLog = (message: string) => {
    logs.value.push(message)
    const overflow = logs.value.length - FRONTEND_LOG_LIMIT
    if (overflow > 0) {
      logs.value.splice(0, overflow)
    }
  }

  const handleProxyStep = (payload: unknown) => {
    const normalized = normalizeProxyStepPayload(payload)
    if (!normalized || !isMainTabKey(normalized.step)) {
      return
    }
    appendLog(
      `[proxy-step] step=${normalized.step} status=${normalized.status}${normalized.message ? ` message=${normalized.message}` : ""}`
    )
    enqueueProxyStep(normalized.step)
  }

  const appendLogs = (entries?: string[]) => {
    if (!entries || !entries.length) {
      return
    }
    entries.forEach((entry) => appendLog(entry))
  }

  const applyInvokeResult = (
    result: InvokeResult | null,
    fallbackMessage: string
  ) => {
    if (!result) {
      appendLog(`${fallbackMessage}Â§±Ë¥•ÔºöÊó†Ê≥ïËøûÊé•ÂêéÁ´Ø`)
      return false
    }
    if (result.message) {
      appendLog(result.message)
    }
    return result.ok
  }

  const startLogStream = () => {
    if (logStreamActive.value) {
      return
    }
    logStreamActive.value = true
    if (logEventUnlisten) {
      try {
        logEventUnlisten()
      } catch {
        // ignore cleanup errors
      }
      logEventUnlisten = null
    }
    if (logPollTimer !== null) {
      clearTimeout(logPollTimer)
      logPollTimer = null
    }

    const applyLogResult = (result: LogPullResult | null) => {
      if (!result) {
        return
      }
      if (Array.isArray(result.items) && result.items.length) {
        appendLogs(result.items)
      }
      if (typeof result.next_id === "number") {
        logCursor.value = result.next_id
      }
    }

    const startPolling = () => {
      const loop = async () => {
        if (!logStreamActive.value) {
          return
        }
        const result = await api.pullLogs({
          after_id: logCursor.value || null,
          timeout_ms: 0,
          max_items: 200,
        })
        if (!logStreamActive.value) {
          return
        }
        applyLogResult(result)
        logPollTimer = setTimeout(loop, 200)
      }
      void loop()
    }

    const startEventStream = async () => {
      if (!isTauriRuntime()) {
        startPolling()
        return
      }

      const initial = await api.pullLogs({
        after_id: logCursor.value || null,
        timeout_ms: 0,
        max_items: 200,
      })
      applyLogResult(initial)

      try {
        const unlisten = await listen<LogEventPayload>("mtga:logs", (event) => {
          const payload = event.payload
          if (!payload) {
            return
          }
          if (Array.isArray(payload.items) && payload.items.length) {
            appendLogs(payload.items)
          }
          if (typeof payload.next_id === "number") {
            logCursor.value = payload.next_id
          }
        })
        if (!logStreamActive.value) {
          try {
            unlisten()
          } catch {
            // ignore cleanup errors
          }
          return
        }
        logEventUnlisten = () => {
          void unlisten()
        }
      } catch (error) {
        console.warn("[mtga] log event listen failed", error)
        startPolling()
      }
    }

    void startEventStream()
  }

  const stopLogStream = () => {
    logStreamActive.value = false
    if (logPollTimer !== null) {
      clearTimeout(logPollTimer)
      logPollTimer = null
    }
    if (logEventUnlisten) {
      try {
        logEventUnlisten()
      } catch {
        // ignore cleanup errors
      }
      logEventUnlisten = null
    }
  }

  const startProxyStepListener = () => {
    if (proxyStepListenerActive.value) {
      return
    }
    proxyStepListenerActive.value = true
    if (proxyStepUnlisten) {
      try {
        proxyStepUnlisten()
      } catch {
        // ignore cleanup errors
      }
      proxyStepUnlisten = null
    }

    if (isBundledRuntime()) {
      return
    }

    const listenProxySteps = async () => {
      try {
        const unlisten = await listen<ProxyStartStepEvent>("mtga:proxy-step", (event) => {
          handleProxyStep(event.payload)
        })
        if (!proxyStepListenerActive.value) {
          try {
            unlisten()
          } catch {
            // ignore cleanup errors
          }
          return
        }
        proxyStepUnlisten = () => {
          void unlisten()
        }
      } catch (error) {
        console.warn("[mtga] proxy step listen failed", error)
      }
    }

    void listenProxySteps()
  }

  const stopProxyStepListener = () => {
    proxyStepListenerActive.value = false
    if (proxyStepUnlisten) {
      try {
        proxyStepUnlisten()
      } catch {
        // ignore cleanup errors
      }
      proxyStepUnlisten = null
    }
  }

  const loadConfig = async () => {
    const result = await api.loadConfig()
    if (!result) {
      return false
    }
    configGroups.value = result.config_groups || []
    currentConfigIndex.value = clampIndex(
      result.current_config_index ?? 0,
      configGroups.value.length
    )
    mappedModelId.value = coerceText(result.mapped_model_id)
    mtgaAuthKey.value = coerceText(result.mtga_auth_key)
    return true
  }

  const saveConfig = async () => {
    const clampedIndex = clampIndex(
      currentConfigIndex.value,
      configGroups.value.length
    )
    currentConfigIndex.value = clampedIndex
    const payload: ConfigPayload = {
      config_groups: configGroups.value,
      current_config_index: clampedIndex,
      mapped_model_id: coerceText(mappedModelId.value),
      mtga_auth_key: coerceText(mtgaAuthKey.value),
    }
    const ok = await api.saveConfig(payload)
    return Boolean(ok)
  }

  const loadAppInfo = async () => {
    const info = await api.getAppInfo()
    if (!info) {
      return false
    }
    appInfo.value = {
      ...DEFAULT_APP_INFO,
      ...info,
    }
    return true
  }

  const buildStartupLogs = (details: Record<string, unknown>) => {
    const envOk = details["env_ok"] === true
    const envMessage = coerceText(details["env_message"])
    if (envMessage) {
      appendLog(`${envOk ? "‚úÖ" : "‚ùå"} ${envMessage}`)
    }
    if (envOk) {
      const runtime = coerceText(details["runtime"])
      if (runtime === "tauri" || runtime === "nuitka") {
        appendLog("üì¶ ËøêË°åÂú®ÊâìÂåÖÁéØÂ¢É‰∏≠")
      } else {
        appendLog("üîß ËøêË°åÂú®ÂºÄÂèëÁéØÂ¢É‰∏≠")
      }
    }

    const allowFlag =
      coerceText(details["allow_unsafe_hosts_flag"]) || "--allow-unsafe-hosts"
    const hostsModifyBlocked = details["hosts_modify_blocked"] === true
    if (hostsModifyBlocked) {
      const status = coerceText(details["hosts_modify_block_status"]) || "unknown"
      appendLog(
        `‚ö†Ô∏è Ê£ÄÊµãÂà∞ hosts Êñá‰ª∂ÂÜôÂÖ•ÂèóÈôêÔºàstatus=${status}ÔºâÔºåÂ∑≤ÂêØÁî®ÂèóÈôê hosts Ê®°ÂºèÔºöÊ∑ªÂä†Â∞ÜÂõûÈÄÄ‰∏∫ËøΩÂä†ÂÜôÂÖ•ÔºàÊó†Ê≥ï‰øùËØÅÂéüÂ≠êÊÄßÂ¢ûÂà†/ÂéªÈáçÔºâÔºåËá™Âä®ÁßªÈô§/ËøòÂéüÂ∞ÜË¢´Á¶ÅÁî®„ÄÇ`
      )
      appendLog(
        `‚ö†Ô∏è ‰Ω†ÂèØ‰ª•ÁÇπÂáª„ÄåÊâìÂºÄhostsÊñá‰ª∂„ÄçÊâãÂä®‰øÆÊîπÔºõÊàñ‰ΩøÁî®ÂêØÂä®ÂèÇÊï∞ ${allowFlag} Ë¶ÜÁõñÊ≠§Ê£ÄÊü•‰ª•Âº∫Âà∂Â∞ùËØïÂéüÂ≠êÂÜôÂÖ•ÔºàÈ£éÈô©Ëá™Ë¥üÔºâ„ÄÇ`
      )
    } else {
      const preflightOk = details["hosts_preflight_ok"] === true
      const preflightStatus = coerceText(details["hosts_preflight_status"])
      if (preflightStatus && !preflightOk) {
        appendLog(
          `‚ö†Ô∏è hosts È¢ÑÊ£ÄÊú™ÈÄöËøáÔºàstatus=${preflightStatus}ÔºâÔºå‰ΩÜÂ∑≤‰ΩøÁî®ÂêØÂä®ÂèÇÊï∞ ${allowFlag} Ë¶ÜÁõñÔºõÂêéÁª≠Ëá™Âä®‰øÆÊîπÂèØËÉΩÂ§±Ë¥•„ÄÇ`
        )
      }
    }

    if (details["explicit_proxy_detected"] === true) {
      appendLog(
        "‚ö†Ô∏è".repeat(21) +
          "\nÊ£ÄÊµãÂà∞ÊòæÂºè‰ª£ÁêÜÈÖçÁΩÆÔºöÈÉ®ÂàÜÂ∫îÁî®ÂèØËÉΩ‰ºòÂÖàËµ∞‰ª£ÁêÜÔºå‰ªéËÄåÁªïËøá hosts ÂØºÊµÅ„ÄÇ"
      )
      appendLog("Âª∫ËÆÆÔºö1. ÂÖ≥Èó≠ÊòæÂºè‰ª£ÁêÜÔºàÂ¶ÇclashÁöÑÁ≥ªÁªü‰ª£ÁêÜÔºâÔºåÊàñÊîπÁî® TUN/VPN")
      appendLog("      2. Ê£ÄÊü• Trae ÁöÑ‰ª£ÁêÜËÆæÁΩÆ„ÄÇ\n" + "‚ö†Ô∏è".repeat(21))
    }

    appendLog("MTGA GUI Â∑≤ÂêØÂä®")
    appendLog("ËØ∑ÈÄâÊã©Êìç‰ΩúÊàñÁõ¥Êé•‰ΩøÁî®‰∏ÄÈîÆÂêØÂä®...")
  }

  const loadStartupStatus = async () => {
    const result = await api.getStartupStatus()
    if (!result) {
      appendLog("ÂêØÂä®Êó•ÂøóÂä†ËΩΩÂ§±Ë¥•ÔºöÊó†Ê≥ïËøûÊé•ÂêéÁ´Ø")
      return false
    }
    if (isRecord(result.details)) {
      buildStartupLogs(result.details)
    }
    return result.ok
  }

  const init = async () => {
    if (initialized.value) {
      startLogStream()
      startProxyStepListener()
      return
    }
    initialized.value = true
    startLogStream()
    startProxyStepListener()
    await Promise.all([loadAppInfo(), loadConfig(), loadStartupStatus()])
  }

  const buildProxyPayload = () => ({
    debug_mode: runtimeOptions.value.debugMode,
    disable_ssl_strict_mode: runtimeOptions.value.disableSslStrict,
    force_stream: runtimeOptions.value.forceStream,
    stream_mode: runtimeOptions.value.streamMode,
  })

  const runGenerateCertificates = async () => {
    const result = await api.generateCertificates()
    return applyInvokeResult(result, "ÁîüÊàêËØÅ‰π¶")
  }

  const runInstallCaCert = async () => {
    const result = await api.installCaCert()
    return applyInvokeResult(result, "ÂÆâË£Ö CA ËØÅ‰π¶")
  }

  const runClearCaCert = async () => {
    const result = await api.clearCaCert()
    return applyInvokeResult(result, "Ê∏ÖÈô§ CA ËØÅ‰π¶")
  }

  const runHostsModify = async (
    mode: "add" | "backup" | "restore" | "remove"
  ) => {
    const result = await api.hostsModify({ mode })
    return applyInvokeResult(result, "hosts Êìç‰Ωú")
  }

  const runHostsOpen = async () => {
    const result = await api.hostsOpen()
    return applyInvokeResult(result, "ÊâìÂºÄ hosts Êñá‰ª∂")
  }

  const runProxyStart = async () => {
    const result = await api.proxyStart(buildProxyPayload())
    return applyInvokeResult(result, "ÂêØÂä®‰ª£ÁêÜÊúçÂä°Âô®")
  }

  const runProxyStop = async () => {
    const result = await api.proxyStop()
    return applyInvokeResult(result, "ÂÅúÊ≠¢‰ª£ÁêÜÊúçÂä°Âô®")
  }

  const runProxyCheckNetwork = async () => {
    const result = await api.proxyCheckNetwork()
    return applyInvokeResult(result, "Ê£ÄÊü•ÁΩëÁªúÁéØÂ¢É")
  }

  const runProxyStartAll = async () => {
    if (isBundledRuntime()) {
      const ok = await api.startProxyStepChannel(handleProxyStep, {
        reset: true,
        startFromLatest: true,
      })
      if (!ok) {
        appendLog("‚ö†Ô∏è proxy-step channel ÂêØÂä®Â§±Ë¥•ÔºåËá™Âä®ÂØºËà™‰∏çÂèØÁî®")
      }
    }
    const result = await api.proxyStartAll(buildProxyPayload())
    return applyInvokeResult(result, "‰∏ÄÈîÆÂêØÂä®ÂÖ®ÈÉ®ÊúçÂä°")
  }

  const runConfigGroupTest = async (index: number) => {
    const result = await api.configGroupTest({ index })
    return applyInvokeResult(result, "ÈÖçÁΩÆÁªÑÊµãÊ¥ª")
  }

  const runUserDataOpenDir = async () => {
    const result = await api.userDataOpenDir()
    return applyInvokeResult(result, "ÊâìÂºÄÁî®Êà∑Êï∞ÊçÆÁõÆÂΩï")
  }

  const runUserDataBackup = async () => {
    const result = await api.userDataBackup()
    return applyInvokeResult(result, "Â§á‰ªΩÁî®Êà∑Êï∞ÊçÆ")
  }

  const runUserDataRestoreLatest = async () => {
    const result = await api.userDataRestoreLatest()
    return applyInvokeResult(result, "ËøòÂéüÁî®Êà∑Êï∞ÊçÆ")
  }

  const runUserDataClear = async () => {
    const result = await api.userDataClear()
    return applyInvokeResult(result, "Ê∏ÖÈô§Áî®Êà∑Êï∞ÊçÆ")
  }

  const runCheckUpdates = async () => {
    const result = await api.checkUpdates()
    const ok = applyInvokeResult(result, "Ê£ÄÊü•Êõ¥Êñ∞")
    if (!result || !isRecord(result.details)) {
      return ok
    }
    const updateResult = isRecord(result.details["update_result"])
      ? result.details["update_result"]
      : result.details
    const status = coerceText(updateResult["status"])
    if (status === "new_version") {
      updateVersionLabel.value = coerceText(updateResult["latest_version"])
      updateNotesHtml.value = coerceText(updateResult["release_notes"])
      updateReleaseUrl.value = coerceText(updateResult["release_url"])
      updateDialogOpen.value = true
    } else if (status === "up_to_date") {
      const latestVersion = coerceText(updateResult["latest_version"])
      if (latestVersion) {
        appendLog(`Â∑≤ÊòØÊúÄÊñ∞ÁâàÊú¨Ôºö${latestVersion}`)
      }
    }
    return ok
  }

  const runCheckUpdatesOnce = async () => {
    if (updateAutoChecked.value) {
      return false
    }
    updateAutoChecked.value = true
    return runCheckUpdates()
  }

  const closeUpdateDialog = () => {
    updateDialogOpen.value = false
  }

  const openUpdateRelease = async () => {
    const url = updateReleaseUrl.value.trim()
    if (!url || typeof window === "undefined") {
      return
    }
    if (isTauriRuntime()) {
      try {
        const { open } = await import("@tauri-apps/plugin-shell")
        await open(url)
        return
      } catch (error) {
        console.warn("[mtga] open release url failed", error)
        appendLog("ÊâìÂºÄÂèëÂ∏ÉÈ°µÂ§±Ë¥•ÔºåËØ∑ÊâãÂä®Â§çÂà∂ÈìæÊé•")
        return
      }
    }
    const opened = window.open(url, "_blank", "noopener,noreferrer")
    if (!opened) {
      window.location.href = url
    }
  }

  const runPlaceholder = (label: string) => {
    appendLog(`${label}ÔºàÂæÖÊé•ÂÖ•ÂêéÁ´ØÔºâ`)
  }

  return {
    configGroups,
    currentConfigIndex,
    mappedModelId,
    mtgaAuthKey,
    runtimeOptions,
    logs,
    logCursor,
    appInfo,
    updateDialogOpen,
    updateVersionLabel,
    updateNotesHtml,
    updateReleaseUrl,
    panelNavTarget,
    panelNavSignal,
    mainTabTarget,
    mainTabSignal,
    appendLog,
    startLogStream,
    stopLogStream,
    startProxyStepListener,
    stopProxyStepListener,
    loadConfig,
    saveConfig,
    init,
    runGenerateCertificates,
    runInstallCaCert,
    runClearCaCert,
    runHostsModify,
    runHostsOpen,
    runProxyStart,
    runProxyStop,
    runProxyCheckNetwork,
    runProxyStartAll,
    runConfigGroupTest,
    runUserDataOpenDir,
    runUserDataBackup,
    runUserDataRestoreLatest,
    runUserDataClear,
    runCheckUpdates,
    runCheckUpdatesOnce,
    closeUpdateDialog,
    openUpdateRelease,
    runPlaceholder,
  }
}
